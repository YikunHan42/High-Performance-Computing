# 函数、重载、函数模板
![[第十周 （函数）-part i.pdf]]


`using namespace std;`定义名称空间（同样厂商不同空间），可以放在`main()`中/用哪个声明哪个

函数分为有返回值和没返回值的
+ 返回值不能是数组，可以是整型、浮点、指针结构和对象（`main()`函数可以不用返回)
+ 数组可以封装成结构体或者类/放在`parameterList`中
+ 多条返回语句的时候，执行第一条后就会中止
+ 函数的返回值也可以作为参数传入



## 函数原型
+ 避免使用原型：**在调用之前定义**
+ 函数原型 = 函数头 +分号
+ ......


## 函数参数和按值传递
+ 存在copy的过程（会带来开销）
+ 函数中声明的变量（包括）参数是私有的，释放的内存在函数结束时释放，称为**局部变量**
+ 命名问题

## 多个参数
逗号分开，形参名字可以隐藏，只用类型

## 传递数组
可以理解为拷贝班级名和人

`int sum_arr(int arr[], int n)`
`int arr[]` arr可以省略
首地址+长度

+ 当且仅当用于函数头和函数原型中的时候，`int *arr`和`int arr[]`的含义才是相同的
+ 两种表示法都意味着$arr$是一个int指针
+ $arr$不仅指向int，还指向int数组
+ arr[i] = \* (arr+i)

将数组作为参数意味着什么
+ 将数组作为参数，传递的实际上是指针，并没有传递数组中的数
+ 传递常规变量的时候，用的是该变量的**拷贝**；函数本身没有办法修改原来的常规变量
+ 传递数组的时候，用的是数组指针的**拷贝**，但是函数使用的却是原来的数组；因此函数可以修改数组中的值

+ `sizeof`数组名是数组长度，`sizeof`指针名返回的是指针变量的长度
+ 为了保护数组内容不被修改，可以使用`const`关键字
+ `void show_array(const double arr[], int n);`并不意味着原始数组必须是常量（下面不改变，但传入的是变量）

或者使用`int sum_arr(const int* begin, const int* end)`定义首尾地址

## 指针和`const`
让指针指向`const`常量
+ `int age = 39`
+ `const int* pt = &age`
+ $pt$的声明并不意味着$pt$指向的值实际上是一个常量，只是对pt而言是常量，也就是说不能通过$pt$修改$age$

## 函数和结构
+ 涉及到函数时，结果变量的行为更接近于单值变量
+ 结构可以赋值给另一个结构，或者按值传递
+ 结构名只是名称，获得地址需要用&
+ C++函数中可以使用结构的地址来传递，也可以按引用传递

## 递归
+ C++函数可以调用自己
+ C++不允许`main()`调用自己

## 函数指针
+ 函数也有地址，存储其机器语言代码内存的开始地址
+ 名字可以作为地址

## C++内联函数
+ 编译器·用相应的函数代码来替换函数调用（有开销）
+ 使用：在函数声明和函数定义前都加上关键字`inline`